const paragraphs = [
    'El desarrollo de aplicaciones siempre ha sido un campo de rápido movimiento. Los riesgos asociados con el desarrollo son bajos en comparación con las posibles recompensas, por lo que los desarrolladores se sienten más libres para probar funciones nuevas, a veces radicalmente diferentes, en el software que producen. Esta velocidad de producción se amplifica aún más en el mundo moderno del desarrollo web, donde las actualizaciones se obtienen simplemente especificando una nueva URL de CDN o ejecutando npm install.',
    "Además, los estándares de desarrollo de aplicaciones web están cambiando. Si bien es cierto que las especificaciones HTML5, CSS3 y JavaScript ES2015 se han estandarizado desde hace algún tiempo, el fenómeno de la iteración basada en características ha llevado a cambios rápidos. Muchos analistas y ejecutivos de empresas de tecnología predicen que los estándares web adoptarán un programa de actualización oficial basado en funciones, lo que les permitirá seguir evolucionando rápidamente.",
    "Algunos de los principales marcos de trabajo de JavaScript discutidos en este libro electrónico están hechos por Google y Facebook. Desde Forbes hasta Airbnb, las empresas grandes y pequeñas usan marcos para revolucionar sus flujos de trabajo de desarrollo web. Veremos más a fondo por qué la adopción ha sido tan generalizada más adelante, pero en general, se trata de permitir experiencias de usuario novedosas y mejorar los flujos de trabajo de desarrollo. La conclusión inmediata es básica, pero extremadamente poderosa: si las empresas exitosas, grandes y pequeñas, usan marcos de JavaScript de manera extensiva, deben ofrecer algún beneficio.",
    "Si aún no has usado JavaScript, ¡no temas! Este es el mejor y más emocionante momento para aprender este idioma hermoso, deslumbrante y desconcertante. La razón por la que existe este libro es por el floreciente campo del desarrollo web, y en este momento el enfoque de ese campo es JavaScript. Los desarrollos relativamente recientes, como el lanzamiento de la plataforma del servidor Node.js, las actualizaciones enriquecidas de las API del navegador y la codificación de las nuevas especificaciones del lenguaje JavaScript han establecido a JavaScript como una opción viable para programar aplicaciones completas, ¡incluso las nativas! Y, por supuesto, todos estos avances han permitido finalmente la producción de los marcos que veremos en las páginas siguientes.",
    "La indentación indica la profundidad de la pila de llamadas. La primera vez que encontrar es llamada, comienza llamandose a sí misma para explorar la solución que comienza con (1 + 5). Esa llamada hara uso de la recursión aún más para explorar cada solución continuada que produzca un número menor o igual a el número objetivo. Como no encuentra uno que llegue al objetivo, retorna null a la primera llamada. Ahí el operador || genera la llamada que explora (1 * 3) para que esta suceda. Esta búsqueda tiene más suerte—su primera llamada recursiva, a través de otra llamada recursiva, encuentra al número objetivo. Esa llamada más interna retorna un string, y cada uno de los operadores || en las llamadas intermedias pasa ese string a lo largo, en última instancia retornando la solución.",
    "Aquí es donde realmente se revela la razón de los marcos MVC. Comprender el cómo de los marcos requiere el conocimiento de todas sus partes, pero comprender por qué realmente solo requiere un breve examen de la vista de una aplicación. La mayoría de los desarrolladores han experimentado la tendencia de las vistas a convertirse rápidamente en componentes que requieren mucho tiempo para un proyecto determinado. Cuando se reduce a lo básico, el diseño de software revela que la vista solo es necesaria para (1) recibir información del usuario y (2) mostrar la salida al usuario. Desde la perspectiva del diseño, varios otros factores importantes hacen que estas experiencias de usuario sean agradables. Sin embargo, desde la perspectiva del desarrollo, la visión presenta una paradoja interesante. Puede ser un portal a través del cual podemos acceder directamente al usuario, pero ¿cómo se puede aprovechar este acceso y permitir que los diseñadores y escritores hagan su magia libremente?",
    "Una vez que tiene suficientes puntos de datos, tiene la intención de utilizar estadísticas para encontrar cuál de estos eventos puede estar relacionado con la transformación a ardilla. La correlación es una medida de dependencia entre variables estadísticas. Una variable estadística no es lo mismo que una variable de programación. En las estadísticas, normalmente tienes un conjunto de medidas, y cada variable se mide para cada medida. La correlación entre variables generalmente se expresa como un valor que varia de -1 a 1. Una correlación de cero significa que las variables no estan relacionadas. Una correlación de uno indica que las dos están perfectamente  relacionadas—si conoces una, también conoces la otra. Uno negativo también significa que las variables están perfectamente relacionadas pero que son opuestas—cuando una es verdadera, la otra es falsa. Para calcular la medida de correlación entre dos variables booleanas, podemos usar el coeficiente phi (φ). Esta es una fórmula cuya entrada es una tabla de frecuencias que contiene la cantidad de veces que las diferentes combinaciones de las variables fueron observadas. El resultado de la fórmula es un número entre -1 y 1 que describe la correlación.",
    "Fácil, ¿no? Incluso cuando esas cosas se hacen por nosotros, aún necesitamos una forma de manejar eventos específicos en la vista y coordinar toda la lógica. Por ejemplo, ¿qué pasa si queremos aceptar un código de cupón del cliente? Incluso si esos códigos están almacenados en una base de datos, necesitamos un lugar para verificarlos y aplicarlos al precio final. ¿Qué pasa si queremos calcular automáticamente los descuentos? Incluso si no estamos interesados en ofrecer características (solo queremos que el cliente salga por la puerta), necesitamos un lugar para cobrar al cliente y solo almacenar la compra si el cargo se realiza. Ahí es donde entra el controlador.",
    "Ya que las propiedades solo agarran su valor, en lugar de contenerlo, los objetos y arrays se almacenan en la memoria de la computadora como secuencias de bits que contienen las direcciónes—el lugar en la memoria—de sus contenidos. Asi que un array con otro array dentro de el consiste en (al menos) una región de  memoria para el array interno, y otra para el array externo, que contiene (entre     otras cosas) un número binario que representa la posición del array interno. Si deseas guardar datos en un archivo para más tarde, o para enviarlo a otra computadora a través de la red, tienes que convertir de alguna manera estos enredos de direcciones de memoria a una descripción que se puede almacenar o    enviar. Supongo, que podrías enviar toda la memoria de tu computadora junto con la dirección del valor que te interesa, pero ese no parece el mejor enfoque. Lo que podemos hacer es serializar los datos. Eso significa que son convertidos a una descripción plana. Un formato de serialización popular llamado JSON (pronunciado “Jason”), que significa JavaScript Object Notation (“Notación de Objetos JavaScript”). Es ampliamente utilizado como un formato de almacenamiento y comunicación de datos en la Web, incluso en otros lenguajes diferentes a JavaScript.",
    "El controlador también podría contener código para manejar descuentos automáticos y otra lógica. Lo importante a reconocer aquí es que el controlador está desvinculado de la vista, no es un componente esencial. Incluso si elimináramos por completo el controlador, el usuario aún podría ver la vista como aparecería con un controlador. Además, nuestros datos, representados por el modelo, también se representan independientemente del controlador. Las vistas y los modelos exponen voluntariamente (y específicamente) propiedades y métodos a los que el controlador debería poder acceder, y le permiten hacer lo que quiera con esa información.",
    "Lo importante a destacar aquí es que estos patrones brindan al desarrollador las herramientas que necesitan para separar las preocupaciones y permiten que los datos se consideren independientemente de los diseños de vista. Permiten desvincular el diseño visual del procesamiento de datos complejos. Algunas de las variaciones entre patrones existen porque algunos de los componentes de MVC son innecesarios o se pueden utilizar de diferentes maneras. Por ejemplo, algunos marcos enfatizan",
    "Al método se le pasa un paso de tiempo y una estructura de datos que le dice qué se mantienen pulsadas las teclas. Lo primero que hace es llamar al método de actualización en todos los actores, produciendo una variedad de actores actualizados. Los actores también tienen tiempo. paso, las claves y el estado, para que puedan basar su actualización en ellos. Solamente el jugador realmente leerá las teclas, ya que ese es el único actor que está controlado por el teclado. Si el juego ya ha terminado, no es necesario realizar ningún otro procesamiento (el juego no se puede ganar después de perder, o viceversa). De lo contrario, el método prueba si el jugador está tocando lava de fondo. Si es así, el juego se pierde, y hemos terminado Finalmente, si el juego realmente continúa, ve si hay otros actores se superponen al jugador.",
    "Esta biblioteca se distribuye con la esperanza de que sea útil, pero sin ninguna garantía; sin siquiera la garantía implícita de comerciabilidad o idoneidad para un fin determinado. Ver el GNU Licencia pública general menor para obtener más detalles. Debería haber recibido una copia de GNU Lesser General Public Licencia junto con esta biblioteca; si no, escribe al Software Libre fundación, inc.",
    "La forma en que se encuentra el centro del jugador muestra cómo los métodos en nuestro Vector type permite que los cálculos con objetos se escriban en un formato relativamente legible camino. Para encontrar el centro del actor, sumamos su posición (su esquina superior izquierda) y la mitad de su tamaño. Ese es el centro en coordenadas de nivel, pero lo necesitamos en píxeles    coordenadas, por lo que luego multiplicamos el vector resultante por nuestra escala de visualización. A continuación, una serie de comprobaciones verifica que la posición del jugador no esté fuera de la rango permitido. Tenga en cuenta que a veces esto establecerá coordenadas de desplazamiento sin sentido   que están por debajo de cero o más allá del área desplazable del elemento. Esto está bien, el DOM los limitará a valores aceptables. Establecer scrollLeft en -10 hacer que se convierta en 0. Habría sido un poco más simple tratar siempre de desplazar el reproductor a la centro de la ventana de visualización. Pero esto crea un efecto bastante discordante. Como tu eres saltando, la vista cambiará constantemente hacia arriba y hacia abajo. Es más agradable para tener un área 'neutral' en el medio de la pantalla donde puede moverse sin causar ningún desplazamiento.", 
    "La mayor parte del código de este capítulo no se preocupa mucho por la encapsulación. por dos razones. En primer lugar, la encapsulación requiere un esfuerzo adicional. Hace programas más grande y requiere la introducción de conceptos e interfaces adicionales. Ya que    solo hay una cantidad limitada de código que puedes arrojar a un lector antes de que sus ojos se pongan vidriosos terminado, he hecho un esfuerzo para mantener el programa pequeño. En segundo lugar, los diversos elementos de este juego están tan estrechamente vinculados entre sí que si el comportamiento de uno de ellos cambió, es poco probable que alguno de los otros sería capaz de permanecer igual. Las interfaces entre los elementos terminarían    codificando muchas suposiciones sobre la forma en que funciona el juego. Esto hace mucho menos efectivos: cada vez que cambia una parte del sistema, todavía tiene que preocuparse por la forma en que afecta a las otras partes porque sus interfaces no cubriría la nueva situación",
    "Para crear estos arreglos, mapearemos sobre las filas y luego sobre su contenido. Recuerda que map pasa el índice del arreglo como un segundo argumento a la función de mapeo, que nos dice las coordenadas x y las coordenadas y de un caracter dado. Las posiciones en el juego serán guardadas como pares de  coordenadas, con la izquierda superior siendo 0,0 y cada cuadrado del fondo siendo 1 unidad de alto y ancho. Para interpretar los caracteres en el plano, el constructor del Nivel usa el objeto de caracteresDelNivel, el cual mapea los elementos a cadenas de caracteres y caracteres de actores a clases. Cuando tipo está en la clase actor, su método estático create es usado para crear un objeto, el cual es agregado a iniciarActores y la función de mapeo regresa 'vacío' para este cuadrado de fondo."
];